% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-

%\VignetteIndexEntry{Examples: Gaussian process modeling and diagnostics}
%\VignetteKeywords{mlegp}
%\VignetteDepends{mlegp}
%\VignettePackage{mlegp}

\section{Examples: Gaussian process fitting and diagnostics}
%\input{cheese}
<<echo=FALSE,print=FALSE, eval=TRUE, results=hide>>=
library(mlegp)
@
\subsection{A simple example}
The function {\it mlegp} is used to fit Gaussian processes (GPs) to a vector or matrix of responses observed under the same set of design parameters. The example below shows how to fit multiple Gaussian processes to multiple outputs $z1$ and $z2$ for the design matrix $x$.
Diagnostic plots are obtained using the {\it plot} function, which graphs observed values vs. cross-validated predicted values for each GP. The plot obtained from the code below appears in Figure (\ref{fig:diag1}).

<<print=TRUE, echo=TRUE, results=hide, eval=TRUE>>=
x = -5:5
z1 = 10 - 5*x + rnorm(length(x))
z2 = 7 * sin(x) + rnorm(length(x))
fitMulti = mlegp(x, cbind(z1,z2))
plot(fitMulti)
@
\begin{figure}[htbp]
  \begin{center}
<<fig=true, print=FALSE, echo=FALSE>>=
plot(fitMulti)
@
    \caption{Gaussian process diagnostic plots. Open circles, cross-validated predictions; solid black lines, observed values; solid red lines, confidence bands corresponding to cross-validated predictions $\pm$ standard deviation.}
    \label{fig:diag1}
  \end{center}
\end{figure}
<<echo = TRUE, results=verbatim, eval=TRUE>>=
@

After the GPs are fit, simply typing the name of the object (e.g., $fitMulti$) will return basic summary information. 
<<echo = TRUE, results=verbatim, eval=TRUE>>=
fitMulti
@
We can also access individual Gaussian processes by specifying the index. The code below, for examples, displays summary information for the first Gaussian process, including diagnostic statistics of cross-validated root mean squared error (CV RMSE) and cross-validated root max squared error (CV RMaxSE), where squared error corresponds to the squared difference between cross-validated predictions and observed values.
<<echo = TRUE, results=verbatim, eval=TRUE>>=
fitMulti[[1]]
@
\subsection{Heteroscedastic responses and the nugget matrix}
In cases where the responses are heteroscedastic (have non-constant variance), it is possible to specify the diagonal nugget matrix up to a multiplicative constant. Future versions of {\it mlegp} will allow more complicated forms of the nugget matrix; currently, we recommend specifying the nugget matrix based on sample variances for replicate design points (which is easily obtained using the function {\it varPerReps}), or the use of prior information. In the example below, we demonstrate how to fit a Gaussian process with a constant nugget term and a Gaussian process where the diagonal nugget matrix is specified up to a multiplicative constant. First we generate heteroscedastic data, with variance related to the design parameter.   

<<echo=TRUE, print=TRUE, results=hide, eval=TRUE>>=
x = seq(0,6,by= 0.1)
z = sin(x) + rnorm(length(x), sd = .10*x)          # variance is not constant
@

By default, a nugget term is automatically estimated if there are replicates in the design matrix, and is not estimated otherwise. However, one can estimate a nugget term by specifying an initial scalar value for the \lq nugget\rq\ argument during the call to
{\it mlegp}. This is done in the code below.  

<<echo=TRUE, print=TRUE, results=hide, eval=TRUE>>=
fit1 = mlegp(x,z, nugget = (0.10*mean(x))**2, param.names = "x1")  # constant nugget (N=I)
@
Alternatively, one can set \lq nugget\rq\ equal to a vector corresponding to the diagonal nugget matrix as described in Section (\ref{sec:mlegp}). This allows the nugget matrix to be specified up to a multiplicative constant, and is demonstrated in the code below. 
<<echo=TRUE, print=TRUE, results=hide, eval=TRUE>>=
fit2 = mlegp(x,z, nugget = x**2, param.names = "x1")                # Aitken version (nugget is specified up to a constant)
@

It is also possible to force a constant nugget term or the diagonal elements of the nugget matrix to have a minimum value by setting the argument \lq min.nugget\rq. This is especially important when the responses are noiseless, and in other situations when the variance-covariance matrix of the GP is not stable otherwise.

Finally, we compare the accuracy of each fitted GP using diagnostic plots. The diagnostic plots are constructed with the argument \lq type\rq\ equal to \lq 2\rq, which plots parameter values vs. cross-validated predictions. The output from the code is displayed in Figure (\ref{fig:nugget}). Note that when a constant nugget term is assumed, confidence bands are overly conservative for low values of $x1$ and are less likely to capture the observed responses for high values of $x1$.    

<<print = TRUE,results = hide, eval = FALSE>>=
par(mfrow = c(1,2))
plot(fit1, type=2); lines(x,sin(x),lty=2)
plot(fit2, type=2); lines(x,sin(x),lty=2)
@

\begin{figure}[htbp]
  \begin{center}
<<fig=true, print = FALSE, echo = FALSE>>=
par(mfrow = c(1,2))
plot(fit1, type=2); lines(x,sin(x),lty=2)
plot(fit2, type=2); lines(x,sin(x),lty=2)
@
    \caption{Diagnostic plots for Gaussian processes with constant nugget term (left) and diagonal nugget matrix (right). Open circles, cross-validated predictions; solid black lines, observed response; dotted black lines, the true (noiseless) response; solid red lines, confidence bands.}
\label{fig:nugget}
  \end{center}
\end{figure}




